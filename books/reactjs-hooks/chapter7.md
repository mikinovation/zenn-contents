---
title: "副作用フック: useEffect"
free: true
---

# 副作用フック（Effect Hook）: useEffect

副作用フック（Effect Hook）とは、その名の通り、副作用のためのフックです。

とはいえ、副作用と言われても、ピンと来づらいかと思います。

まず名前の由来から説明し、何が副作用とされているのかの2つについて、初めに解説をします。

# 副作用の名前の由来

日本語だとReact公式ドキュメントには「副作用」と訳されています。

英語の公式ドキュメントでは「Effect」と名前がついています。

直訳は意味が異なるのですが、これは、英語が元々は「side-effect」なのを、「effect」と略してしまっているためです。

「side-effect」はそのまま直訳すると「副作用」ですので、このことを知っていると納得できるかと思います。

# 何が副作用なのか？

では、名前の由来がわかったところで、ここでは一体何のことを副作用とみなしているのかについて見ていきましょう。

ここで言う副作用とは、以下の例が挙げられます。

- Reactコンポーネント内から、外部データの取得をすることによって起こる他のコンポーネントへの影響
- レンダーの最中に実行できない操作（Reactコンポーネント内から、外部データの取得をする操作）

ほかにも例はありますが、まずはこの例をもとに解説します。

例えばですが、チャットアプリがあったとしましょう。

とてもシンプルな構成をイメージするとすれば、以下のようになるかと思います。

| アプリ概要 | 着目する機能 |
| ---- | ---- |
| チャットアプリ | アプリケーションが読み込まれた時に、チャットデータを表示する |

この時に意識をしたいのが、チャットデータの存在場所です。

チャットのようなユーザーの入力によって追加されるデータは、サーバーにあることが多いです。

![](https://storage.googleapis.com/zenn-user-upload/owx8pvmf4dupxgypw86tixppz16l)

つまり、ここで言うチャットデータは「外部データ」という認識ができます。

チャットアプリ自体の、チャット欄を表示するフロントエンド部分は、Reactによって実装され、出力されます。

![](https://storage.googleapis.com/zenn-user-upload/1fyk6euf84kicnntjbhllyqpaf1q)

| アプリの状態 | 処理のフロー |
| ---- | ---- |
| ① ローディング画像表示 | Reactコンポーネント内から外部データ（チャットデータ）取得中 |
| ② 取得した外部データ（チャットデータ）表示 | 表示が変わり、他のコンポーネントに影響 |

この例を見ると、勘の良い方は気がつかれたかもしれません。

実はuseEffectは、クラスコンポーネントの場合の、以下の技法をAPIで1つにまとめたものだからです。

- componentDidMount
- componentDidUpdate
- componentWillUnmount

:::message
厳密には違いがあるので、それについては先の項目に解説があります。
:::

# useEffectの簡単な実用例

説明を聞くだけでは、まだ深く理解をするには難しいと思うので、先ほどのカウンターアプリにuseEffectを追加して、実際にソースコードを書いてみましょう。

ここでは、先ほどの練習問題で取り組んだ、簡易版カウンターアプリに `useEffect` を使って、HTMLドキュメントのタイトルにも、クリックされたカウント数を表示させるようにします。

つまり、クリックが発生した回数を、HTMLドキュメントのタイトルにも反映させるというものです。

イメージしやすくするために、簡潔なワイヤーフレーム、遷移設計を以下にお見せしましょう。

![](https://storage.googleapis.com/zenn-user-upload/3zcz2clntvwuef1ikq0k80gm1ogf)

# 副作用フック（Effect Hook）の基本構文

まずは基本構文の確認をします。

State Hookと少し違うので、注意しましょう。

 `useEffect` は、基本的には以下の構造を持ちます。

```jsx
useEffect(callback, [dependencies]);
```

 `useEffect` は、2つのフックを持ちます。

主に3つのパターンがあるので、それぞれまずは構文を見ていきます。

#### パターン1

``` jsx
import React, { useState, useEffect } from 'react';

function コンポーネント名() {
  useEffect(() => {
    // 毎回のレンダーごとに実行される
  });
}
```

#### パターン 2

``` jsx
import React, { useState, useEffect } from 'react';

function コンポーネント名() {
  useEffect(() => {
    // 初回のレンダー時に「一度だけ実行」される
    // & propかstateが変化した場合のみ、毎回のレンダー後実行される
  }, [prop, state]);
}
```

#### パターン 3

``` jsx
import React, { useState, useEffect } from 'react';

function コンポーネント名() {
  useEffect(() => {
    // 初回のレンダー時に「一度だけ実行」される
  }, []);
}
```

第1引数の `callback` は問題ないかと思うので、第2引数の `dependencies` について少し解説をします。

 `useEffect` を使えるようになる前は、 `componentDidUpdate` を使って、以下のような処理をしていました。

```jsx
componentDidUpdate(prevProps, orevState) {
  if (prevState.count !== this.state.count) {
    document.title = `${this.state.count} times clicked!`;
  }
}
```

条件分岐を使って、副作用のスキップをReactに伝えています。

**「count stateが変化している場合は、HTMLドキュメントのタイトルのcountをクリックイベントと連動して表示する」** ということを指示しています。

逆を言えば、 **「count stateが変化していない場合は、この処理はスキップ」** と指示しているということにもなります。

これでも十分意図したことは実装できていますが、 `useEffect` の第2引数 `dependencies` を使用すると、もっと短く、可読性の高い記述が可能になります。

```jsx
useEffect(() => {
  document.titlle = `${this.state.count} times clicked!`;
}, [count]);
```

処理内容としては同じことをしていますが、このように可読性を高く、不必要な処理をしなくても済むよう意識して実装することを **「最適化する」** と言います。

勘の良い方であれば、「先ほどの基本構文3パターンあるうちの、パターン1では実装できないのだろうか？」と考えられた人もいるかもしれません。

それぞれの処理の差を解説すると以下のようになります。

| パターン1 | パターン2 |
| ---- | ---- |
| count stateに入っていた値が **何であれ、副作用の適用を実行** する | count stateに入っていた数値を覚えておき、 **同じ値が来た場合のみ副作用をスキップ** する |

わかりやすい例えにするとすれば、行きつけのお気に入りのカフェがあるとしましょう。

毎日欠かさず1年以上通っているお気に入りのカフェで、注文する飲み物もいつも定番のドライカプチーノだとしましょう。

スタッフは、全員あなたのことを常連客だと認識して、名前も覚えてくれています。

でも、1年以上通って、毎日同じ定番の飲み物を注文しているのに、一向にいつも注文する飲み物を覚えてもらえないとどうでしょうか？

毎回レジで注文する際に、飲み物の名前を言う手間が生じます。

常連客だと認識されているのに、飲み物だけは毎回同じものを注文しなければ利用できないのは嫌ですよね。

これがパターン1です。

しかし、 `useEffect` の第2引数を使うと、一度入店して注文しただけで、同じ飲み物のオーダーが入れば、スタッフが「今日はドライカプチーノですか？」と向こうから聞いてくれるのです。

1年も通えば、入店するだけでお気に入りのドライカプチーノを既に準備してくれるようになります。

これがパターン2です。

![](https://storage.googleapis.com/zenn-user-upload/ldw2f33ks2qtffalnb67zp7yjj27)