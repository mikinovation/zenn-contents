---
title: "副作用フック: クリーンアップ関数"
---

# 2種類ある副作用

これまでのチャプターでは、副作用フックの基本的な使い方について学びました。

ここからは、副作用フックのもう少し詳しい性質や使い方を学習していきましょう。

実は、Reactコンポーネントにおける副作用は、2種類に分類されます。

**クリーンアップ関数を必要としない副作用**と、**必要とする副作用**です。

具体的にそれぞれ見ていきましょう。

# クリーンアップとは？

**クリーンアップ**とは、**必要のなくなったコンポーネントのstateを更新しないようにする関数**を示します。

このように、残ると不都合が出るものがある場合、メモリリークが発生しないようクリーンアップをする必要があります。

そういったことが起こらないように「cleanup = 片付け」ておくので、クリーンアップという名前がついています。

# なぜクリーンアップ関数が必要なのか？

もう少し具体的に、クリーンアップについて解説をしていきたいと思います。

例えば、外部から画像をAPIを利用して取得するアプリケーションを開発しているとしましょう。

画像データを取得してstateを更新すると、画面を更新する仕組みです。

この仕組みの中で、ユーザーはユーザーのスピードで画面移動しますから、更新をして表示をしようと思った画面が、もう別の画面に移ってしまい、更新すべきコンポーネントがない場合もあります。

このことを、**アンマウントされたDOM**とReactのライフサイクルメソッドイベントでは表現します。

そして、このアンマウントされた、要するにもう更新が必要なくなってしまったDOMコンポーネントに対して、stateをそれでも更新しようとすると、メモリリークの警告が表示されます。

- **実際に出力される警告**

```
Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.
```

要するに、**更新が必要なくなってしまったDOM（アンマウントされたDOM）に対しては、stateの更新をしないようにするべき**、ということなのです。

ユーザーとしての経験を思い出すと、これは理解しやすいかもしれません。

先ほどの画像アプリケーションで、猫の画像一覧ページを見ていて、今度は子犬の画像一覧ページを選択したとします。

でも、その間に気が変わって、ウサギの画像一覧ページの方を見たくなったので、子犬の画像一覧が出てくる前に、ウサギの画像一覧ページ表示に切り替えました。

![](https://storage.googleapis.com/zenn-user-upload/96wyjfx441oa9vc1tx9ayp40paoh)

この場合

- 🐱 猫の画像一覧ページ
- 🐶 子犬の画像一覧ページ
- 🐰 ウサギの画像一覧ページ

の3つの画面更新が考えられるのですが、子犬の画像一覧ページが更新される前に、ウサギの画像一覧ページに移動をしました。

ユーザーとしても見たいページは「猫 → ウサギ一覧ページ」なので、子犬の画像一覧ページは表示されて欲しくないわけです。

ここで子犬一覧画像stateを更新しても、ユーザーは既にウサギの画像一覧ページの画面更新をしたので、必要がなくなってしまいます。

無駄を省くためにも、アンマウントされた子犬の画像一覧ページのDOMコンポーネントに対して、state更新をしないのが望ましいということなんです。

そこで、DOMがアンマウント、つまり画面更新が必要なくなったDOMを把握するために、 副作用フックのクリーンアップ関数を使用します。

**クリーンアップ関数**とは、**副作用フックが返す関数**のことです。

クリーンアップ関数は、**DOMがアンマウントされたタイミング**で呼び出されます。

不必要なコンポーネントが出てきたら、瞬時に片付けに取りかかってくれるというイメージです。

# クリーンアップ関数の構造

クリーンアップ関数の基本構文は、以下です。

```javascript
useEffect(() => {
  副作用
  return () => {
    クリーンアップ
  }
}, []);
```

# クリーンアップ関数を必要としない副作用

まずはクリーンアップが必要ない副作用からです。

「手動での何かしらのDOM変更すること」は、クリーンアップを必要としない時です。

上記で学んだように、「アンマウントされた不必要なコンポーネントがない場合」であれば、クリーンアップは必要ありません。

そのほかで言うと、以下もクリーンアップを必要としない時とされています。

- ネットワークリクエストの送信
- 何かのログの記録

要するに、**不要なアンマウントコンポーネントがなく、ReactがDOMを更新後に、メモリリークの残骸を気にせず、追加のコードを実行したい場合**に、クリーンアップ関数を含まない副作用を使います。

実質、クリーンアップ自体の役割は、残るとメモリリークが起こって挙動を起こす内容のcleanupです。

それを踏まえると、DOMの更新後に、特に気にせず追加コードの実行を行っても良いのであれば、クリーンアップは必要そうではありませんね。

## useEffectが呼び出されるタイミング

副作用フックである `useEffect` が呼び出されるタイミングを理解しておくことは、非常に大切なので、ここで説明しておきます。

 `useEffect` は、毎回のレンダー後に呼び出されます。

1. レンダー
2. 副作用

この順番です。

今までのReactのライフサイクルメソッドベースで考えると、「マウント」と「更新」という観点で考えてしまいがちになるのですが、 `useEffect` の場合、 **「レンダーの後」** に副作用が起こります。

そのため、副作用関数は、**初回のレンダーの時**と、**更新するたび**呼び出されます。

:::message
これはデフォルトでの仕様ですが、カスタマイズもできます。カスタマイズする方法は、後述します。
:::

:::message
 `useEffect` に渡される関数は、毎回レンダーされるごとに、全く別物の関数として渡されます。
 前のレンダーで渡された関数を、最新レンダー時の関数に置き換えているのです。
 これは、古いstateの値の参照をしないようにするためです。
:::

## クリーンアップ関数が呼び出されるタイミング

クリーンアップ関数が必要な場合について詳しく実例を見ていく前に、クリーンアップ関数が呼び出されるフローについて、把握しておきたいと思います。

まずは、クリーンアップ関数の呼び出されるタイミングを視覚的に見るため、シンプルなアプリケーションを例に解説をします。

チャプター9で、副作用フックの簡易的な使い方を学習した際に実装した、カウンターアプリを使って、視覚的に反映も一緒に見ていきましょう。

副作用フックで、クリーンアップを必要とする場合を見ていきたいので、少しだけ検証を見やすくするために手を加えています。

```diff jsx:src/App.js
const [count, setCount] = useState(0);

useEffect(() => {
+  console.log('3. 副作用フックの中直下の範囲');
  document.title = `${count} times clicked!`;
+  return () => {
+    console.log('2. HTMLドキュメントタイトル変更後の範囲 👈 re-render後に実行される');
+  };
}, [count]);

+ console.log('1. render直前の範囲');
return (
  // JSX省略
);
```

アプリケーションが読み込まれただけの状態での反映は、以下です。

![](https://storage.googleapis.com/zenn-user-upload/r9vqpwm7lcnpjqhz1hrz68e83gtd)

1. render直前の範囲
2. （クリーンアップ関数の呼び出しなし）
3. 副作用フックの中直下の範囲

3つ `console.log` で出力したい文字列を書き加えていますが、上記の2つだけがアプリケーション読み込み直後では呼び出されていることに着目してください。

では、クリックイベントを実行するとどうなるか見てみます。

![](https://storage.googleapis.com/zenn-user-upload/8m6ans329gdyp8ybwvbr8wrv3208)

1. render直前の範囲
2. HTMLドキュメントタイトル変更後の範囲 👈 re-render後に実行される
3. 副作用フックの中直下の範囲

「副作用フックの中直下の範囲」が2番目にくるかと思いきや、最も深い useEffect スコープ内の「HTMLドキュメントタイトル変更後の範囲 👈 re-render後に実行される」が2番目にきていますね。

これはなぜでしょうか？

まず、 useEffect は、レンダーの後に副作用として起こるのでしたね。

なので、アプリケーションが読み込まれた直後も、「レンダー → 副作用」の順で読み込まれます。

そして、クリーンアップは、実は副作用の前に読み込まれる性質を持っています。

そうすることで、不必要になったコンポーネント（アンマウントされたDOMなど）が発生した時に、瞬時にその情報をキャッチし、そういった不要なコンポーネントのstateの更新を、しないようにしてくれる仕組みになっています。

クリーンアップを必要とする場合、クリーンアップ関数の呼び出されるタイミングを知っていることで、思わぬ挙動を防ぐことができます。

このことを踏まえて、クリーンアップ関数が必要な場合を見ていきましょう。

# クリーンアップ関数を必要とする副作用

さて、いよいよクリーンアップ関数が必要な場合について、学んでいきましょう。

クリーンアップが必要なのは、必要のなくなったコンポーネントのstateを更新しないようにする時でしたね。

ここでも例を使って解説をします。

このチャプター前半でもお話をした、動物画像一覧表示のアプリケーションをもとに解説します。

アプリケーションの概要は、上記の **「なぜクリーンアップ関数が必要なのか？」** の項目にある通りです。

ユーザーの行動としては、以下です。

| 本来選択された画面更新 | ユーザーが希望した画面更新 |
| ---- | ---- |
| 「🐱 → 🐶 → 🐰」 | 「🐱 → 🐰」 |

猫画像一覧を見終えて、子犬画像一覧を選択しましたが、気が変わって、画面更新される前にウサギ画像一覧を選択したという状況です。

```jsx
function Animals(props) {
  // 非同期で取得するデータ
  const [result, setResult] = useState(null);

  // 副作用フック
  useEffect(() => {
    // コンポーネントがアンマウントされたかどうかを保持する変数
    let unmounted = false;

    // 非同期無名関数の呼び出し
    const fetchAnimals = async() => {
      //非同期でデータ、🐱🐰🐶の画像一覧を取得
      const result = await getAnimals();//架空の関数

      // アンマウントされていなければstateを更新（🐱🐰stateのみ更新）
      if(!unmounted) {
        setResult(result);
      };
    }
    fetchAnimals();

    // クリーンアップ関数: 上記の非同期処理が完了する前にアンマウントが起こると、stateは更新されない
    //（🐶stateは更新されない）
    return () => {
      unmounted = true;
    }
  }, []);

  return <div>{ result ? <p>{ result }</p> : <p>loading...</p> }</div>
}
```

さて、上記の **「クリーンアップ関数が呼び出されるタイミング」** の項目でクリーンアップ関数が実行されるタイミングを見たのをもとにすると、動物画像アプリケーションでは、以下のフローで処理が行われます。

- **ローディング直後**

1. レンダー
2. 副作用（ `unmounted = false` ）

- **ページ更新**

1. レンダー
2. クリーンアップ関数（ `unmounted = true` ）
3. 副作用（ `unmounted = false` ）

![](https://storage.googleapis.com/zenn-user-upload/3sqrxl37a0dflk4wkgyox4tlkyac)

先ほど実際にユーザーになってシミュレーションをした時のことを思い出してみましょう。

ページ更新時のフローで、アンマウントされた子犬の画像一覧ページがstate更新されず、「猫 → ウサギ」と画面更新されるのが理解できるかと思います。

クリーンアップ関数は、使用頻度がとても高い技法ではありませんが、全く使用しないわけではありません。

少し概念を完全に理解するには時間がかかるかもしれませんが、ポイントとして、**クリーンアップ関数が必要な場合とそうでない場合** と **クリーンアップ関数が呼び出されるフロー** の2つの理解ができていれば、理解が深まるかと思います。